- 외래키가 있는 곳을 연관관계의 주인으로 정해라.


- 엔티티는 @Getter는 열어두고 @Setter는 가급적 열어두면 안된다.(데이터가 변하므로)
꼭 필요한 경우에만 사용해야 하며 예제에서는 모두 열었으나 실무에서는 변경을 위한 비지니스 메서드를 따로 추가하자.


- 모든 연관관계는 지연로딩으로 설정해야 한다.(LAZY)
즉시로딩(EAGER)은 예측이 어렵고 어떤 SQL이 실행될지 추적하기 어렵다.
@XToOne은 기본이 EAGER이므로 꼭 LAZY로 설정해줘야 한다.
연관된 엔티티를 DB에서 함께 조회하려면 fetch join 또는 엔티티 그래프 기능을 사용한다.

- 스프링부트 자동설정(엔티티 -> 컬럼)
1. 카멜 케이스 -> 언더스코어
2. . -> 언더스코어
3. 대문자 -> 소문자


- 실무에선 @ManyToMany를 사용하면 안된다.
중간에 엔티티를 하나 더 추가하여 @ManyToOne과 @OneToMany로 매핑하여 사용하자.


- 서버 배포
해당 디렉토리로 가서 ./gradlew clean build를 하면 /build/libs에 .jar가 생기는데
이 파일을 서버에 배포 후 java -jar jar명 을 통해 실행하면 된다.


- p6spy(build.gradle 추가)를 통하여 로그를 명세적으로 출력할 수 있다.
단 운영 배포 시에는 성능 문제가 있을 수 있으므로 고민해봐야 한다.


- 변경감지
준영속엔티티란 영속성 컨텍스트가 더는 관리하지 않는 엔티티를 말한다.
준영속엔티티를 수정하는 방법은 두 가지가 있는데 merge와 변경 감지이다.
변경 감지는 이는 영속성 컨테이너에서 수정할 데이터를 다시 조회한 후
트랜잭션안에서 변경할 값을 선택(Setter)하면 트랜잭션은 커밋 시점에 이를 감지하여 변경한다.(flush)
해서 데이터 베이스에 Update Query가 실행된다.

병합(merge)은 준영속 상태의 엔티티를 영속상태로 변경할 때 사용하는 기능이다.
변경 감지는 원하는 속성만 선택하여 값을 변경할 수 있지만 병합은 모든 속성이 변경된다.
따라서 값이 없으면 모두 null로 업데이트될 위험성이 있다.
단순하고 확실한 경우에 병합을 쓰는 것은 괜찮으나 변경 감지가 더 좋은 방법이므로 변경 감지를 사용하면 된다.


- 엔티티를 API 응답으로 외부에 노출하는 것은 여러 가지 문제가 많아 지양해야 한다.
  때문에 응답값을 DTO로 변환하여 반환해야 한다.


- OSIV : Open Session In View(하이버네이트)
ON
장점
이 전략은 @Transactional을 만나 최초 DB커넥션이 생성되고 API 응답이 끝날 때까지 영속성 컨테이너와
DB커넥션을 유지한다. 그래서 View Template나 API Controller에서 지연 로딩이 가능했던 것이다.
지연 로딩은 영속성 컨텍스트가 살아있어야 가능하고, 영속성 컨텍스트는 기본적으로 DB커넥션을 유지한다.

단점
오랜 시간동안 DB커넥션을 유지하기 때문에 실시간 트래픽이 중요한 어플리케이션에선 커넥션이 모자랄 수 있다.
이것은 결국 장애로 이어진다.
예를 들어 컨트롤러에서 외부 API를 호출하면 외부 API 대기시간만큼 커넥션 리소스를 반환하지 못하고, 유지해야한다.

OFF
영속성 컨텍스트 생존범위 : Service ~ Repository
트랜잭션이 종료할 때 영속성 컨텍스트를 닫고 디비 커넥션을 반환한다. 따라서 커넥션 리소스를 낭비하지 않는다.
이 경우 모든 지연로딩을 트랙잭션 안에서 처리해야 한다. 따라서 지금까지 작성한 많은 지연로딩 코드를 트랜잭션 안으로
넣어야하는 단점이 있다. 그리규 View Template에서 지연 로딩이 동작하지 않는다. 결론적으로 트랜잭션이 끝나기 전에
지연 로딩을 강제로 호출해야 한다.

OSIV OFF로 인해 Controller의 지연로딩 코드를 트랜잭션 안으로 넣어야할 경우
복잡성을 관리하는 좋은 방법이 있다. 바로 Commend와 Query를 분리하는 것인데
복잡한 화면을 출력하기 위한 쿼리는 화면에 맞추어 성능을 최적화 하는 것이 중요하기 때문이며 유지보수 관점에서 큰 의미가 있다.
예를 들어 OrderApiController.java의 @GetMapping("/api/v3/orders")를 분리한다고 할 경우
OrderService(핵심 비지니스로직)와 OrderQueryService(화면 또는 API에 맞춘 서비스 - 주로 읽기 트랜잭션에서 사용)
을 나누는 것이다.

강사님은 커넥션이 많이 발생할 수 있는 어플레케이션에서는 OSIV를 OFF하고 Admin처럼 커넥션이 거의 발생하지 않는
프로젝트에서는 OSIV를 ON한다.


- Spring Data JPA
JpaRepository라는 인터페이스를 제공하여 기본적인 CRUD 기능을 모두 제공한다.

findByName처럼 일반화하기 힘들어 제공하지 않는 기능도 메서드 이름으로 정확한 JPQL 쿼리를 실행한다.
예를 들어 List<Member> findByName(String name);라고 인터페이스에 선언하면
select m from member m where m.name = :name

스프링 데이터 JPA는 JPA를 사용하여 기능만 제공해줄 뿐 결국 JPA 자체를 이해하는 것이 중요함을 잊지말자.