- 엔티티를 API응답으로 외부에 노출하는 것은 여러 가지 문제가 많아 지양해야 한다.
  때문에 응답값을 DTO로 변환하여 반환해야 한다.

- 엔티티 연관관계 패치 전략은 즉시 로딩(EAGER)은 다양한 문제가 발생할 수 있어 지연 로딩(LAZY)를 써야한다.

- OSIV : Open Session In View(하이버네이트)
ON
장점
이 전략은 @Transactional을 만나 최초 DB커넥션이 생성되고 API 응답이 끝날 때까지 영속성 컨테이너와
DB커넥션을 유지한다. 그래서 View Template나 API Controller에서 지연 로딩이 가능했던 것이다.
지연 로딩은 영속성 컨텍스트가 살아있어야 가능하고, 영속성 컨텍스트는 기본적으로 DB커넥션을 유지한다.

단점
오랜 시간동안 DB커넥션을 유지하기 때문에 실시간 트래픽이 중요한 어플리케이션에선 커넥션이 모자랄 수 있다.
이것은 결국 장애로 이어진다.
예를 들어 컨트롤러에서 외부 API를 호출하면 외부 API 대기시간만큼 커넥션 리소스를 반환하지 못하고, 유지해야한다.

OFF
영속성 컨텍스트 생존범위 : Service ~ Repository
트랜잭션이 종료할 때 영속성 컨텍스트를 닫고 디비 커넥션을 반환한다. 따라서 커넥션 리소스를 낭비하지 않는다.
이 경우 모든 지연로딩을 트랙잭션 안에서 처리해야 한다. 따라서 지금까지 작성한 많은 지연로딩 코드를 트랜잭션 안으로
넣어야하는 단점이 있다. 그리규 View Template에서 지연 로딩이 동작하지 않는다. 결론적으로 트랜잭션이 끝나기 전에
지연 로딩을 강제로 호출해야 한다.

OSIV OFF로 인해 Controller의 지연로딩 코드를 트랜잭션 안으로 넣어야할 경우
복잡성을 관리하는 좋은 방법이 있다. 바로 Commend와 Query를 분리하는 것인데
복잡한 화면을 출력하기 위한 쿼리는 화면에 맞추어 성능을 최적화 하는 것이 중요하기 때문이며 유지보수 관점에서 큰 의미가 있다.
예를 들어 OrderApiController.java의 @GetMapping("/api/v3/orders")를 분리한다고 할 경우
OrderService(핵심 비지니스로직)와 OrderQueryService(화면 또는 API에 맞춘 서비스 - 주로 읽기 트랜잭션에서 사용)
을 나누는 것이다.

강사님은 커넥션이 많이 발생할 수 있는 어플레케이션에서는 OSIV를 OFF하고 Admin처럼 커넥션이 거의 발생하지 않는
프로젝트에서는 OSIV를 ON한다.

- Spring Data JPA
JpaRepository라는 인터페이스를 제공하여 기본적인 CRUD 기능을 모두 제공한다.

findByName처럼 일반화하기 힘들어 제공하지 않는 기능도 메서드 이름으로 정확한 JPQL 쿼리를 실행한다.
예를 들어 List<Member> findByName(String name);라고 인터페이스에 선언하면
select m from member m where m.name = :name

스프링 데이터 JPA는 JPA를 사용하여 기능만 제공해줄 뿐 결국 JPA 자체를 이해하는 것이 중요함을 잊지말자.